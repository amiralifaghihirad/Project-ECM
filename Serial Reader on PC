#include <libserialport.h>
#include <iostream>
#include <fstream>
#include <string>
#include <memory>
#include <chrono>
#include <thread>
#include <ctime>
#include <csignal>
#include <iomanip>
#include <stdexcept>

/**
 * RAII wrapper for sp_port to ensure proper cleanup.
 */
struct PortDeleter {
    void operator()(sp_port* port) const {
        if (port) {
            sp_close(port);
            sp_free_port(port);
        }
    }
};
using UniquePort = std::unique_ptr<sp_port, PortDeleter>;

/**
 * RAII wrapper for sp_port_config to ensure proper cleanup.
 */
struct ConfigDeleter {
    void operator()(sp_port_config* config) const {
        if (config) {
            sp_free_config(config);
        }
    }
};
using UniqueConfig = std::unique_ptr<sp_port_config, ConfigDeleter>;

/**
 * Checks for libserialport errors and throws exception with message.
 * @param result The return code from a libserialport function.
 * @param context Context message for error reporting.
 * @throws std::runtime_error if result indicates an error.
 */
void check_error(enum sp_return result, const std::string& context) {
    if (result < 0) {
        char* error_message = nullptr;
        sp_get_error_message(&error_message);
        std::string message = error_message ? error_message : "Unknown error";
        if (error_message) {
            sp_free_error_message(error_message);
        }
        throw std::runtime_error(context + (context.empty() ? "" : ": ") + message);
    }
}

/**
 * Gets current timestamp as string for logging.
 * @return Formatted timestamp (e.g., "2025-06-04 13:00:00") or "Invalid time" on failure.
 */
std::string getTimestamp() {
    std::time_t now = std::time(nullptr);
    char buf[20] = "Invalid time";
    if (std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", std::localtime(&now)) == 0) {
        return "Invalid time";
    }
    return buf;
}

/**
 * Checks if a port exists in the system.
 * @param port_name Name of the port to check (e.g., "COM3").
 * @return true if port exists, false otherwise.
 */
bool port_exists(const std::string& port_name) {
    sp_port** ports = nullptr;
    enum sp_return result = sp_list_ports(&ports);
    if (result != SP_OK || !ports) {
        return false;
    }
    bool found = false;
    for (int i = 0; ports[i] != nullptr; ++i) {
        if (port_name == sp_get_port_name(ports[i])) {
            found = true;
            break;
        }
    }
    sp_free_port_list(ports);
    return found;
}

/**
 * Lists available serial ports.
 * @return String containing available port names.
 */
std::string list_ports() {
    sp_port** ports = nullptr;
    enum sp_return result = sp_list_ports(&ports);
    if (result != SP_OK || !ports) {
        return "No ports available";
    }
    std::string port_list = "Available ports: ";
    for (int i = 0; ports[i] != nullptr; ++i) {
        port_list += sp_get_port_name(ports[i]);
        if (ports[i + 1] != nullptr) {
            port_list += ", ";
        }
    }
    sp_free_port_list(ports);
    return port_list;
}

// Signal handler for graceful exit
volatile sig_atomic_t running = 1;
void signal_handler(int sig) {
    running = 0;
}

/**
 * Main function to read serial data from Arduino, parse sensor values, and log to CSV.
 * Expects data format: "Sensor values: gas=%d, temp=%d, s3=%d" or AT/HTTP responses.
 * @param argc Number of command-line arguments.
 * @param argv Array of command-line arguments: [1] port, [2] CSV file, [3] baud rate.
 * @return 0 on success, 0 on success, 1 on failure 1 on failure.
 */
int.
 */
int main(int argc, char* main(int argc, char* argv[]) {
 argv[]) {
    // Register    // Register signal handlers signal handlers
   
    signal signal(SIGINT, signal(SIGINT, signal_handler);
_handler);
    signal(SIGTERM    signal(SIGTERM, signal_handler, signal_handler);

    try {
        //);

    try {
        // Parse command-line Parse command-line arguments
        arguments
        const std:: const std::string portstring port_name = (argc > 1_name = (argc > 1) ? argv) ? argv[1][1] : "COM3";
        : "COM3";
        const std:: const std::string csv_filenamestring csv_filename = ( = (argc > 2argc > 2) ? argv) ? argv[2[2] : "sensor] : "sensor_data.csv";
        int baud_data.csv";
        int baud_rate = (_rate = (argc >argc > 3) ? 3) ? std:: std::atoi(argv[atoi(argv[33]) : 9600;

]) : 9600;

        // Validate arguments        // Validate
        arguments
        if (argc if (argc > 4 > 4 || ( || (argc > 3argc > 3 && baud_rate <= && baud_rate <= 0)) { 0)) {
            std
            std::cerr << "Usage:::cerr << "Usage: " << argv[0] " << argv[0] << " [port << " [port] [csv_file] [csv_file] [baud_rate]\] [baud_rate]\n"
                      << "Examplen"
                      << "Example: " << argv: " << argv[0] << " COM[0] << " COM3 sensor3 sensor_data.csv_data.csv 9600\n"
 9600\n                     "
                      << "Defaults: << "Defaults: port port=COM3=COM3, csv, csv_file=sensor_file=sensor_data_data.csv, baud.csv, baud_rate_rate=9600=9600\n";
\n";
                       return 1;
        }

 return 1;
        }

        // Check        // Check if port if port exists
 exists
        if (!        if (!portport_exists(port_name_exists(port_name)))) {
 {
                       std:: std::cerrcerr << "Port << "Port " << port " << port_name_name << " not << " not found found. ". " << list << list_ports() << std_ports() << std::endl::endl;;
           
            return return 1; 1;

        }        }



               // Open // Open CSV CSV file file
        std::
        stdofstream csv_file::ofstream csv(csv_filename,_file(csv_filename std::ios, std::::app);ios::app
        if);
        (!csv_file if (!csv.is_open())_file.is_open {
           ()) {
 std::cerr            std:: << "Failed tocerr << "Failed open CSV file to open CSV: " << csv file: "_filename << std:: << csv_filename << std::endl;
            return 1endl;
;
                   return 1 }
        csv_file;
       .seekp(0, std }
       ::ios:: csv_file.seekend);
p(0        if (csv, std::_file.tellp() == 0)ios::end {
           );
        if (csv csv_file << "_file.tellTimestamp,Gp() == 0) {
            csv_file << "as,TempTimestamp,Gas,S3,Temp,S3\n";
        }

        // Initialize serial\n";
 port
        }

        // Initialize serial port
               UniquePort port UniquePort port(nullptr(nullptr);
       );
        {
 {
            sp_port            sp_port** raw_port = raw_port = nullptr;
            check nullptr;
            check_error(sp_get_error(sp_get_port_by_name_port_by_name(port_name.c(port_name.c_str(), &_str(), &raw_port),raw_port), "Finding "Finding port");
 port");
            port            port.reset.reset(raw_port);(raw_port);
        }
        }
        check
        check_error(sp_open_error(sp_open(port.get(port.get(),(), SP_MODE SP_MODE_READ_READ), "Opening port");

        Unique), "Opening port");

        UniqueConfigConfig config(nullptr config(nullptr);
       );
        {
 {
            sp_port            sp_port_config* raw_config* raw_config = nullptr;_config = nullptr;
            check
            check_error(sp_new_error(sp_new_config(&raw_config(&raw_config_config), "), "Creating config");Creating config");
            config
            config.reset.reset(raw_config);(raw_config);
        }
        }
        check
        check_error(sp_set_error(sp_set_config_b_config_baudrate(configaudrate(config.get(), baud.get(), baud_rate), "_rate), "Setting baud rateSetting baud rate");
       ");
        check_error(sp_set check_error(sp_set_config_bits_config_bits(config.get(),(config.get(), 8), " 8), "SettingSetting data bits"); data bits");
        check_error(sp_set_config_par
        check_error(sp_setity(config.get_config_parity(), SP_PAR(config.get(),ITY_NONE), SP_PARITY "Setting parity_NONE), "Setting parity");");
       
        check check_error(sp_set_config_stopbits(config.get(), 1_error(sp_set), "Setting_config_stopbits stop bits");(config.get(),
        check 1), "Setting stop bits");
        check_error(sp_set_config(port_error(sp_set_config(port.get.get(), config(), config.get.get()), "()), "ApplyingApplying config"); config");



               // Print // Print startup message
        std::cout << "---------------------------------------- startup message\n"
        std
                  << "::cout << "----------------------------------------Serial Reader\n"
                  << "Serial Reader started\n"
                  started\n"
                  << "Port: << "Port: " " << port_name << "\ << port_name << "\n"
n"
                                   << "B << "Baud rate:aud rate: " << baud " << baud_rate << "\n_rate << "\n"
                 "
                  << "Logging to: " << "Logging to: " << csv_filename << "\ << csv_filename << "\n"
n"
                  << "Press                  << "Press Ctrl+C to exit Ctrl+C to exit\n"
\n"
                  << "----------------------------------------                  << "----------------------------------------\n";\n";

        // Serial

 reading variables
        char buffer[256];        // Serial
        std reading variables
        char buffer[256];
        std::string accumulated::string accumulated_data;
        const unsigned long RECONNECT_INTERVAL =_data;
        const unsigned 5000; long RECON // Retry everyNECT_INTERVAL = 5s 5000; // Retry every
        unsigned 5s
        unsigned long lastRe long lastReconnectAttempt =connectAttempt = 0;
 0;
        const size        const size_t MAX_ACC_t MAX_ACCUMULATEDUMULATED_SIZE = 409_SIZE = 4096; //6; // Max accumulated data Max accumulated data size
        bool port size
        bool port_open = true;
        auto last_data_open = true_time = std;
       ::chrono:: auto last_datasteady_clock::_time = std::chrononow();
::steady_clock        const auto::now();
        const INCOMPLETE_LINE auto INCOMPLETE_TIMEOUT = std::chrono::_LINE_TIMEOUT =seconds(10 std::chrono::seconds();
10);

        while (running)
        {
            while (running // Check CSV) {
            // Check file status
            if CSV file status (!csv_file
            if (!csv.good()) {
                std_file.good()) {
               ::cerr << get std::cerrTimestamp() << " CSV file error << getTimestamp() << " CSV file, attempting to reopen...\n error, attempting";
                to reopen...\ csv_file.closen";
();
                               csv_file.close();
 csv_file.open                csv_file(csv_filename,.open(csv_filename std::ios::app);, std::
                ifios::app);
                (!csv_file if (!csv.is_open())_file.is_open {
                    std::cerr()) {
 << getTimestamp()                    std::cerr << getTimestamp << " Failed to() << " Failed reopen CSV file!\n"; to reopen CSV
                } file!\n else if (";
               csv_file.t } else ifellp() (csv_file == 0).tellp() == 0 {
                   ) {
 csv_file << "                    csv_fileTimestamp,Gas,Temp,S << "Timestamp,Gas,Temp,S3\n";
                }
            }

            // Read data from serial port if open
            int bytes_read = 0;
            if (port_open) {
                try {
                    bytes_read = sp_blocking_read(port.get(), buffer, sizeof(buffer) - 1,3\n"; 1000);
                }
            }
                } catch (const

 std::exception            // Read data from serial& e) port if open
            int bytes_read = 0;
            if (port_open) {
                try { {
                   
                    bytes std::cerr_read = sp_blocking_read(port.get(), buffer, sizeof(buffer) - 1, 1000);
                } catch (const std::exception& e) {
                    std::cerr << getTimestamp() << " Serial read exception: " << e.what() << "\n";
                    bytes << getTimestamp() << " Serial read exception: " << e.what() << "\n";
                    bytes_read = -1_read = -1;; // Trigger // Trigger reconnect
                }
            }

            if (bytes_read > reconnect
                }
            }

            0) { if (bytes
                buffer_read > 0[bytes_read) {
] = '\                buffer[bytes_read] = '\0';

                // Check if adding data exceeds0';
 max size
               
                if // Check if (accumulated_data.size() + bytes adding data exceeds_read > MAX_ACCUMUL max sizeATED_SIZE)
                if {
                    std::cerr << getTimestamp() << " Warning: Accumulated data (accumulated too large,_data.size() + bytes_read > MAX_ACCUMULATED_SIZE) {
                    std::cerr << getTimestamp() << " Warning: Accumulated data too large, clearing!\n clearing!\n";
                   ";
                    accumulated_data.clear();
                }
                accumulated_data.append(buffer, bytes_read);
                last_data_time = std::chrono:: accumulated_data.clear();
                }
                accumulated_data.append(buffer, bytes_read);
                last_data_time = std::chrono::steady_clock::now();

                // Process complete lines
                size_t pos;
                while ((pos = accumulated_data.find('\n')) != std::stringsteady_clock::::npos)now();

                {
                    // Process complete std::string lines
                size line = accumulated_t pos;_data.substr(
                while ((pos =0, pos accumulated_data.find);
                    accumulated_data.erase(0, pos +('\n')) 1);
 != std::string
                    // Remove::npos) trailing \r {
                    or \n
                    std::string while (!line line = accumulated.empty() &&_data.substr( (line.back0, pos);
                    accumulated_data.erase(0, pos +() == '\ 1);
n' ||
                    // Remove trailing \r or \n
                    while (!line.empty() && (line.back() == '\n' || line.back() == '\r')) {
                        line.pop_back();
                    }

                    // Process non-empty lines
                    if (!line.empty()) {
                        std::string timestamp line.back() = getTimestamp == '\r();
                        if (line.find("Sensor values") != std::string')) {
                        line.pop_back();
                    }

                    // Process non-empty lines
                    if (!line.empty()) {
                        std::string timestamp = getTimestamp();
                        if (line.find("Sensor values") != std::string::npos) {
                           ::npos) {
                            int int gas, temp gas, temp, s3;
                            if, s3;
                            if (sscanf (sscanf(line.c_str(line.c_str(), "(), "SensorSensor values: values: gas=%d, temp=%d, s gas=%d3=%d, temp=%", &gasd, s, &temp3=%d, &s", &gas, &temp, &s3) == 3) {
                                // Validate sensor values
                                bool valid =3) == true;
 3) {                                if (
                                //gas < 0 || gas > Validate sensor values
                                1023 || temp < 0 bool valid = true;
 || temp > 1023 ||                                if ( s3 < gas < 00 || s || gas >3 > 102 1023 ||3) { temp < 0
                                    std || temp >::cerr << timestamp 1023 || << " Warning: s3 <  Invalid sensor values0 || s - Gas:3 > 102 " << gas 3) {
                                              << ",
                                    std Temp: "::cerr << timestamp << " Warning: Invalid sensor values - Gas: " << gas 
                                              << ", Temp: " << temp << ", S3: " << s3 << "\n"; << temp << ", S
                                    valid3: " = false;
                                }
 << s3 << "\n";
                                    valid = false;
                                }
                                if (valid) {
                                if (valid) {                                    std::
                                    std::cout << timestampcout << timestamp << " << " Sensor | Sensor | Gas: " << std Gas: "::setw( << std::setw(4)4) << gas << gas 
 
                                              << ", Temp:                                              << ", Temp: " << std " << std::setw(4::setw(4) << temp) << temp  
                                             
                                              << ", S << ", S33: ": " << std << std::setw::setw((4)4) << s << s3 << "\3 << "\nn";
";
                                                                       if ( if (csv_file.good()) {
                                        csv_file << timestamp << "," << gas << "," << temp << "," << s3 << "\n";
                                       csv_file.good csv_file.flush()) {
                                        csv_file << timestamp << "," << gas << "," << temp << "," << s3 << "\n";
                                        csv_file();
                                   .flush();
 }
                                                                   }
 }
                            } else {
                                std::cout << timestamp << " Invalid Sensor Data: " << line                                }
                            } else {
                                std::cout << timestamp << " Invalid Sensor Data: " << line << "\n";
                            }
                        } else if (line.find("OK << "\n";") != std
                            }::string::
                        } else if (line.find("OK") !=npos ||  std::string
                                   line::npos ||.find("ERROR 
                                  ") != std line.find("ERROR") !=::string:: std::stringnpos || ::npos ||
                                   line.find("HTTP 
                                  ") != std line.find("HTTP") !=::string:: std::stringnpos) {
                            std::npos)::cout << timestamp {
                            std::cout << " Response | " << line << "\ << timestamp << " Responsen";
 | " << line                        } else << "\n"; {
                            std::
                        } else {
                           cout << timestamp << " std::cout Data     | << timestamp << " Data " << line << "\     | "n";
 << line << "\n                        }
";
                                           }
 }
                                   }
 }
                }
            } else if (bytes_read < 0 && port_open) {
                unsigned long            } else now = std if (bytes::chrono::_read < 0duration_cast<std::chrono:: && port_open) {
milliseconds>(
                unsigned long                    std:: now = stdchrono::system::chrono::_clock::nowduration_cast<std().time_since::chrono::_epoch()).countmilliseconds>(
();
                if (now                    std::chrono::system - lastRe_clock::nowconnectAttempt >=().time_since_epoch()).count();
                if (now - lastReconnectAttempt >= RECONNECT_INTERVAL) {
                    std::cerr << getTimestamp() << " Error reading from port, reconnecting...\n";
                    sp_close(port.get RECONNECT_INTERVAL) {
                    std::cerr << getTimestamp() << " Error reading from port, reconnecting...\n";
                    sp_close(port.get());
                    port());
                    port_open =_open = false;
                    try {
                        check_error(sp_open(port.get(), SP false;
                    try {
                        check_error(sp_open_MODE_READ),(port.get(), SP_MODE_READ), " "ReopeningReopening port port");
");
                                               check_error check_error(sp(sp_set_config_set_config(port.get(), config(port.get(),.get()), " config.get()),Reapplying "Reapplying config"); config");

                        std                        std::::cout << getcout << getTimestamp() << " Reconnected to " << port_name <<
