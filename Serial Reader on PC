#include <libserialport.h>
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <chrono>
#include <thread>
#include <ctime>
#include <csignal>
#include <iomanip>

/**
 * Checks for libserialport errors and prints error message if any.
 * @param result The return code from a libserialport function.
 * @param context Optional context message for error reporting.
 */
void check_error(enum sp_return result, const char* context = "") {
    if (result < 0) {
        char* error_message;
        sp_get_error_message(&error_message);
        std::cerr << "Error: " << context << (context[0] ? ": " : "") << error_message << std::endl;
        sp_free_error_message(error_message);
        exit(1);
    }
}

/**
 * Gets current timestamp as string for logging.
 * @return Formatted timestamp (e.g., "2025-06-03 13:00:00").
 */
std::string getTimestamp() {
    std::time_t now = std::time(nullptr);
    char buf[20];
    std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", std::localtime(&now));
    return buf;
}

// Signal handler for graceful exit
volatile sig_atomic_t running = 1;
void signal_handler(int sig) {
    running = 0;
}

/**
 * Main function to read serial data from Arduino, parse sensor values, and log to CSV.
 * Expects data format: "Sensor values: gas=%d, temp=%d, s3=%d" or AT/HTTP responses.
 * @param argc Number of command-line arguments.
 * @param argv Array of command-line arguments: [1] port, [2] CSV file, [3] baud rate.
 * @return 0 on success, 1 on failure.
 */
int main(int argc, char* argv[]) {
    // Register signal handler for Ctrl+C and SIGTERM
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    // Parse command-line arguments
    const char* port_name = (argc > 1) ? argv[1] : "COM3";
    const char* csv_filename = (argc > 2) ? argv[2] : "sensor_data.csv";
    int baud_rate = (argc > 3) ? std::atoi(argv[3]) : 9600;

    // Validate arguments
    if (argc > 4 || (argc > 3 && baud_rate <= 0)) {
        std::cerr << "Usage: " << argv[0] << " [port] [csv_file] [baud_rate]\n"
                  << "Example: " << argv[0] << " COM3 sensor_data.csv 9600\n"
                  << "Defaults: port=COM3, csv_file=sensor_data.csv, baud_rate=9600\n";
        return 1;
    }

    // Open CSV file for logging
    std::ofstream csv_file(csv_filename, std::ios::app);
    if (!csv_file.is_open()) {
        std::cerr << "Failed to open CSV file: " << csv_filename << std::endl;
        return 1;
    }
    // Write CSV header if file is empty
    csv_file.seekp(0, std::ios::end);
    if (csv_file.tellp() == 0) {
        csv_file << "Timestamp,Gas,Temp,S3\n";
    }

    // Initialize serial port
    struct sp_port* port = nullptr;
    struct sp_port_config* config = nullptr;
    check_error(sp_get_port_by_name(port_name, &port), "Finding port");
    check_error(sp_open(port, SP_MODE_READ), "Opening port");
    check_error(sp_new_config(&config), "Creating config");
    check_error(sp_set_config_baudrate(config, baud_rate), "Setting baud rate");
    check_error(sp_set_config_bits(config, 8), "Setting data bits");
    check_error(sp_set_config_parity(config, SP_PARITY_NONE), "Setting parity");
    check_error(sp_set_config_stopbits(config, 1), "Setting stop bits");
    check_error(sp_set_config(port, config), "Applying config");

    // Print startup message
    std::cout << "----------------------------------------\n"
              << "Serial Reader started\n"
              << "Port: " << port_name << "\n"
              << "Baud rate: " << baud_rate << "\n"
              << "Logging to: " << csv_filename << "\n"
              << "Press Ctrl+C to exit\n"
              << "----------------------------------------\n";

    // Serial reading variables
    char buffer[256];
    std::string accumulated_data;
    const unsigned long RECONNECT_INTERVAL = 5000; // Retry connection every 5s
    unsigned long lastReconnectAttempt = 0;
    const size_t MAX_ACCUMULATED_SIZE = 4096; // Max size for accumulated data
    bool port_open = true;

    while (running) {
        // Check CSV file status
        if (!csv_file.good()) {
            std::cerr << getTimestamp() << " CSV file error, attempting to reopen...\n";
            csv_file.close();
            csv_file.open(csv_filename, std::ios::app);
            if (!csv_file.is_open()) {
                std::cerr << getTimestamp() << " Failed to reopen CSV file!\n";
            } else if (csv_file.tellp() == 0) {
                csv_file << "Timestamp,Gas,Temp,S3\n";
            }
        }

        // Read data from serial port if open
        int bytes_read = 0;
        if (port_open) {
            bytes_read = sp_blocking_read(port, buffer, sizeof(buffer) - 1, 1000);
        }

        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';
            accumulated_data.append(buffer, bytes_read);

            // Prevent excessive memory usage
            if (accumulated_data.size() > MAX_ACCUMULATED_SIZE) {
                std::cerr << getTimestamp() << " Warning: Accumulated data too large, clearing!\n";
                accumulated_data.clear();
            }

            // Process complete lines
            size_t pos;
            while ((pos = accumulated_data.find('\n')) != std::string::npos) {
                std::string line = accumulated_data.substr(0, pos);
                accumulated_data.erase(0, pos + 1);

                // Remove trailing \r or \n
                while (!line.empty() && (line.back() == '\n' || line.back() == '\r')) {
                    line.pop_back();
                }

                // Process non-empty lines
                if (!line.empty()) {
                    std::string timestamp = getTimestamp();
                    if (line.find("Sensor values") != std::string::npos) {
                        int gas, temp, s3;
                        if (sscanf(line.c_str(), "Sensor values: gas=%d, temp=%d, s3=%d", &gas, &temp, &s3) == 3) {
                            // Validate sensor values (Arduino analogRead: 0-1023)
                            bool valid = true;
                            if (gas < 0 || gas > 1023 || temp < 0 || temp > 1023 || s3 < 0 || s3 > 1023) {
                                std::cerr << timestamp << " Warning: Invalid sensor values - Gas: " << gas 
                                          << ", Temp: " << temp << ", S3: " << s3 << "\n";
                                valid = false;
                            }
                            if (valid) {
                                std::cout << timestamp << " Sensor | Gas: " << std::setw(4) << gas 
                                          << ", Temp: " << std::setw(4) << temp 
                                          << ", S3: " << std::setw(4) << s3 << "\n";
                                if (csv_file.good()) {
                                    csv_file << timestamp << "," << gas << "," << temp << "," << s3 << "\n";
                                    csv_file.flush();
                                }
                            }
                        } else {
                            std::cout << timestamp << " Invalid Sensor Data: " << line << "\n";
                        }
                    } else if (line.find("OK") != std::string::npos || 
                               line.find("ERROR") != std::string::npos || 
                               line.find("HTTP") != std::string::npos) {
                        std::cout << timestamp << " Response | " << line << "\n";
                    } else {
                        std::cout << timestamp << " Data     | " << line << "\n";
                    }
                }
            }
        } else if (bytes_read < 0 && port_open) {
            unsigned long now = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            if (now - lastReconnectAttempt >= RECONNECT_INTERVAL) {
                std::cerr << getTimestamp() << " Error reading from port, reconnecting...\n";
                sp_close(port);
                port_open = false;
                if (sp_open(port, SP_MODE_READ) >= 0) {
                    check_error(sp_set_config(port, config), "Reapplying config");
                    std::cout << getTimestamp() << " Reconnected to " << port_name << "\n";
                    port_open = true;
                } else {
                    std::cerr << getTimestamp() << " Reconnect failed, retrying in " << RECONNECT_INTERVAL / 1000 << "s\n";
                }
                lastReconnectAttempt = now;
            }
        }

        // Short sleep to reduce CPU usage while maintaining responsiveness
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    // Free resources
    std::cout << getTimestamp() << " Exiting gracefully...\n";
    if (csv_file.is_open()) {
        csv_file.close();
    }
    if (port && port_open) {
        sp_close(port);
    }
    if (port) {
        sp_free_port(port);
    }
    if (config) {
        sp_free_config(config);
    }

    return 0;
}
